;;; ZED.scm
 
(-2) "list"
comment:
#true
(!) (!) "list"
 
(2) "list"
comment:
#true
(1) (!) "list"
 
(force!) "value"
comment:
(002) "promise?" "value"
(002) "force" "value"
 
(force!) "value"
comment:
#true
"value"
 
(!) "pair"
comment:
#true
(force!) (002) "cdr" "pair"
 
(1) "pair"
comment:
#true
(force!) (002) "car" "pair"
 
(=) "value1" "value2"
comment:
#true
(003) "eqv?" "value1" "value2"
 
(add-between-ra) "list" "item"
comment:
#true
(002) "reverse" (add-between!) "item" "list" nil
 
(add-between) "item" "list"
comment:
#true
(002) "reverse" (add-between!) "item" "list" nil
 
(add-between!) "item" "list" "collect"
comment:
(002) "null?" "list"
"collect"
 
(add-between!) "item" "list" "collect"
comment:
(002) "null?" (002) "cdr" "list"
(003) "cons" (002) "car" "list" "collect"
 
(add-between!) "item" "list" "collect"
comment:
#true
(add-between!) "item" (002) "cdr" "list" (003) "cons" "item" (003) "cons" (002) "car" "list" "collect"
 
(alpha)
comment:
#true
(write-all) (flatten) (newlines) (by-four) (function-sort) (sentences) (leading-newline) (space-newline) (tab-replace) (newline-space-tab-repeats) (newline-space) (filter) not-return? (read-all)
 
(application?) "expression"
comment:
#true
(003) "and" (002) "not" (002) "null?" "expression" (002) "pair?" (002) "car" "expression"
 
(arity) "arity-hash" "function"
comment:
#true
(002) "cdr" (003) "assoc" "function" "arity-hash"
 
(arity-hash) "program"
comment:
#true
(003) "append" (003) "map" arity-hash! "program" (003) "append" (007) "list" (003) "cons" "'ZED001" 1 (003) "cons" "'ZEDor" 2 (003) "cons" "'ZEDand" 2 (003) "cons" "'ZEDse" 2 (003) "cons" "'ZEDc" 2 (003) "cons" "'ZEDquote" 1 (099) "list" (003) "cons" "'ZED002" 2 (003) "cons" "'ZED003" 3 (003) "cons" "'ZED004" 4 (003) "cons" "'ZED005" 5 (003) "cons" "'ZED006" 6 (003) "cons" "'ZED007" 7 (003) "cons" "'ZED008" 8 (003) "cons" "'ZED009" 9 (003) "cons" "'ZED010" 10 (003) "cons" "'ZED011" 11 (003) "cons" "'ZED012" 12 (003) "cons" "'ZED013" 13 (003) "cons" "'ZED014" 14 (003) "cons" "'ZED015" 15 (003) "cons" "'ZED016" 16 (003) "cons" "'ZED017" 17 (003) "cons" "'ZED018" 18 (003) "cons" "'ZED019" 19 (003) "cons" "'ZED020" 20 (003) "cons" "'ZED021" 21 (003) "cons" "'ZED022" 22 (003) "cons" "'ZED023" 23 (003) "cons" "'ZED024" 24 (003) "cons" "'ZED025" 25 (003) "cons" "'ZED026" 26 (003) "cons" "'ZED027" 27 (003) "cons" "'ZED028" 28 (003) "cons" "'ZED029" 29 (003) "cons" "'ZED030" 30 (003) "cons" "'ZED031" 31 (003) "cons" "'ZED032" 32 (003) "cons" "'ZED033" 33 (003) "cons" "'ZED034" 34 (003) "cons" "'ZED035" 35 (003) "cons" "'ZED036" 36 (003) "cons" "'ZED037" 37 (003) "cons" "'ZED038" 38 (003) "cons" "'ZED039" 39 (003) "cons" "'ZED040" 40 (003) "cons" "'ZED041" 41 (003) "cons" "'ZED042" 42 (003) "cons" "'ZED043" 43 (003) "cons" "'ZED044" 44 (003) "cons" "'ZED045" 45 (003) "cons" "'ZED046" 46 (003) "cons" "'ZED047" 47 (003) "cons" "'ZED048" 48 (003) "cons" "'ZED049" 49 (003) "cons" "'ZED050" 50 (003) "cons" "'ZED051" 51 (003) "cons" "'ZED052" 52 (003) "cons" "'ZED053" 53 (003) "cons" "'ZED054" 54 (003) "cons" "'ZED055" 55 (003) "cons" "'ZED056" 56 (003) "cons" "'ZED057" 57 (003) "cons" "'ZED058" 58 (003) "cons" "'ZED059" 59 (003) "cons" "'ZED060" 60 (003) "cons" "'ZED061" 61 (003) "cons" "'ZED062" 62 (003) "cons" "'ZED063" 63 (003) "cons" "'ZED064" 64 (003) "cons" "'ZED065" 65 (003) "cons" "'ZED066" 66 (003) "cons" "'ZED067" 67 (003) "cons" "'ZED068" 68 (003) "cons" "'ZED069" 69 (003) "cons" "'ZED070" 70 (003) "cons" "'ZED071" 71 (003) "cons" "'ZED072" 72 (003) "cons" "'ZED073" 73 (003) "cons" "'ZED074" 74 (003) "cons" "'ZED075" 75 (003) "cons" "'ZED076" 76 (003) "cons" "'ZED077" 77 (003) "cons" "'ZED078" 78 (003) "cons" "'ZED079" 79 (003) "cons" "'ZED080" 80 (003) "cons" "'ZED081" 81 (003) "cons" "'ZED082" 82 (003) "cons" "'ZED083" 83 (003) "cons" "'ZED084" 84 (003) "cons" "'ZED085" 85 (003) "cons" "'ZED086" 86 (003) "cons" "'ZED087" 87 (003) "cons" "'ZED088" 88 (003) "cons" "'ZED089" 89 (003) "cons" "'ZED090" 90 (003) "cons" "'ZED091" 91 (003) "cons" "'ZED092" 92 (003) "cons" "'ZED093" 93 (003) "cons" "'ZED094" 94 (003) "cons" "'ZED095" 95 (003) "cons" "'ZED096" 96 (003) "cons" "'ZED097" 97 (003) "cons" "'ZED098" 98 (003) "cons" "'ZED099" 99
 
(arity-hash!) "clause"
comment:
#true
(003) "cons" (clause-name) "clause" (clause-arity) "clause"
 
(by-four) "sentences"
comment:
#true
(002) "reverse" (by-four!) "sentences" nil
 
(by-four!) "sentences" "collect"
comment:
(002) "null?" "sentences"
"collect"
 
(by-four!) "sentences" "collect"
comment:
#true
(by-four!) (002) "cddddr" "sentences" (003) "cons" (005) "list" (002) "car" "sentences" (002) "cadr" "sentences" (002) "caddr" "sentences" (002) "cadddr" "sentences" "collect"
 
(by-three) "sentences"
comment:
#true
(002) "reverse" (by-three!) "sentences" nil
 
(by-three!) "sentences" "collect"
comment:
(002) "null?" "sentences"
"collect"
 
(by-three!) "sentences" "collect"
comment:
#true
(by-three!) (002) "cdddr" "sentences" (003) "cons" (004) "list" (002) "car" "sentences" (002) "cadr" "sentences" (002) "caddr" "sentences" "collect"
 
(character-less?) "character1" "character2"
comment:
#true
(003) "<" (002) "char->integer" "character1" (002) "char->integer" "character2"
 
(clause-arguments) "clause"
comment:
#true
(002) "cadr" "clause"
 
(clause-arguments-agree) "clause1" "clause2"
comment:
(003) "equal?" (clause-arguments) "clause1" (clause-arguments) "clause2"
(clause-arguments) "clause1"
 
(clause-arity) "clause"
comment:
#true
(002) "length" (clause-arguments) "clause"
 
(clause-body) "clause"
comment:
#true
(002) "cddr" "clause"
 
(clause-less?) "clause1" "clause2"
comment:
#true
(sentence-less?) (002) "car" "clause1" (002) "car" "clause2"
 
(clause-name) "clause"
comment:
#true
(002) "car" "clause"
 
(clause-name-agree) "clause1" "clause2"
comment:
(003) "eq?" (clause-name) "clause1" (clause-name) "clause2"
(clause-name) "clause1"
 
(combine-all) "program"
comment:
#true
(002) "reverse" (combine-all!) "program" nil
 
(combine-all!) "program" "collect"
comment:
(002) "null?" "program"
"collect"
 
(combine-all!) "program" "collect"
comment:
(002) "null?" (002) "cdr" "program"
(003) "cons" (002) "car" "program" "collect"
 
(combine-all!) "program" "collect"
comment:
(003) "eq?" (clause-name) (002) "car" "program" (clause-name) (002) "cadr" "program"
(combine-all!) (combine-head-clauses) "program" "collect"
 
(combine-all!) "program" "collect"
comment:
#true
(combine-all!) (002) "cdr" "program" (003) "cons" (002) "car" "program" "collect"
 
(combine-clauses) "clause1" "clause2"
comment:
#true
(003) "cons" (clause-name-agree) "clause1" "clause2" (003) "cons" (clause-arguments-agree) "clause1" "clause2" (003) "append" (clause-body) "clause1" (clause-body) "clause2"
 
(combine-head-clauses) "program"
comment:
#true
(003) "cons" (combine-clauses) (002) "car" "program" (002) "cadr" "program" (002) "cddr" "program"
 
(combine-program-clauses) "program"
comment:
#true
(combine-all) (ready-program) "program"
 
(comp)
comment:
#true
(comp!)
 
(comp!)
comment:
#true
(comp!a) (combine-program-clauses) (by-three) (read-sentences) (discard-comments) (gr) ""(function-sort)"" (function-sort) (gr) ""(sentences)"" (sentences) (gr) ""(leading-newline)"" (leading-newline) (gr) ""(space-newline)"" (space-newline) (gr) ""(tab-replace)"" (tab-replace) (gr) ""(newline-space-tab-repeats)"" (newline-space-tab-repeats) (gr) ""(newline-space)"" (newline-space) (gr) ""(filter)"" (filter) not-return? (gr) ""(read-all)"" (read-all)
 
(comp!a) "combined"
comment:
#true
(comp!aa) (programize) "combined" (arity-hash) "combined"
 
(comp!aa) "programized"
comment:
#true
(004) "begin" (002) "display" (primitives) (001) "newline" (002) "display" "programized"
 
(condefy) "expressions"
comment:
#true
(002) "reverse" (condefy!) "expressions" nil
 
(condefy!) "expressions" "collect"
comment:
(002) "null?" "expressions"
"collect"
 
(condefy!) "expressions" "collect"
comment:
#true
(condefy!) (002) "cddr" "expressions" (003) "cons" (003) "append" (002) "car" "expressions" (002) "cadr" "expressions" "collect"
 
(digit?) "character"
comment:
#true
(011) "or" (003) "eqv?" #0 "character" (003) "eqv?" #1 "character" (003) "eqv?" #2 "character" (003) "eqv?" #3 "character" (003) "eqv?" #4 "character" (003) "eqv?" #5 "character" (003) "eqv?" #6 "character" (003) "eqv?" #7 "character" (003) "eqv?" #8 "character" (003) "eqv?" #9 "character"
 
(discard-comments) "program"
comment:
#true
(002) "reverse" (discard-comments!) "program" nil
 
(discard-comments!) "program" "collect"
comment:
(002) "null?" "program"
"collect"
 
(discard-comments!) "program" "collect"
comment:
#true
(discard-comments!) (002) "cddddr" "program" (003) "cons" (002) "cadddr" "program" (003) "cons" (002) "caddr" "program" (003) "cons" (002) "car" "program" "collect"
 
(dr) "value"
comment:
#true
(005) "begin" (002) "display" (pr) (dr!) "value" (001) "newline" (001) "newline" "value"
 
(dr!) "value"
comment:
(002) "pair?" "value"
(mp) dr! (first) 64 "value"
 
(dr!) "value"
comment:
#true
"value"
 
(drr) "value"
comment:
#true
(005) "begin" (002) "display" (pr) "value" (001) "newline" (001) "newline" "value"
 
(fi) "function" "list"
comment:
(002) "null?" "list"
nil
 
(fi) "function" "list"
comment:
(002) "function" (1) "list"
(c) (1) "list" (fi) "function" (!) "list"
 
(fi) "function" "list"
comment:
#true
(fi) "function" (!) "list"
 
(filter) "predicate" "list"
comment:
#true
(002) "reverse" (filter!) "predicate" "list" nil
 
(filter!) "predicate" "list" "collect"
comment:
(002) "null?" "list"
"collect"
 
(filter!) "predicate" "list" "collect"
comment:
(002) "predicate" (002) "car" "list"
(filter!) "predicate" (002) "cdr" "list" (003) "cons" (002) "car" "list" "collect"
 
(filter!) "predicate" "list" "collect"
comment:
#true
(filter!) "predicate" (002) "cdr" "list" "collect"
 
(first) "integer" "list"
comment:
(002) "not" (002) "pair?" "list"
"list"
 
(first) "integer" "list"
comment:
#true
(first!) "integer" "list" nil
 
(first!) "integer" "list" "collect"
comment:
(002) "zero?" "integer"
(002) "reverse" "collect"
 
(first!) "integer" "list" "collect"
comment:
(003) ">" "integer" 0
(first!) (003) "-" "integer" 1 (!) "list" (003) "cons" (1) "list"  "collect"
 
(flatten) "object"
comment:
#true
(flatten!) "object" nil
 
(flatten!) "object" "collect"
comment:
(002) "null?" "object"
"collect"
 
(flatten!) "object" "collect"
comment:
(002) "not" (002) "pair?" "object"
(003) "cons" "object" "collect"
 
(flatten!) "object" "collect"
comment:
#true
(flatten!) (002) "car" "object" (003) "append" (flatten!) (002) "cdr" "object" "collect"
 
(flexefy) "part"
comment:
(002) "symbol?" "part"
(flexefy!) (002) "string->list" (002) "symbol->string" "part"
 
(flexefy) "part"
comment:
(002) "string?" "part"
(002) "string->symbol" "part"
 
(flexefy) "part"
comment:
(002) "exact?" "part"
"part"
 
(flexefy) "part"
comment:
#true
(002) "string->number" (003) "string-append" ""#e"" (002) "number->string" "part"
 
(flexefy!) "part"
comment:
(003) "equal?" "part" (006) "list" ## #t #r #u #e
#true
 
(flexefy!) "part"
comment:
(003) "equal?" "part" (007) "list" ## #f #a #l #s #e
#false
 
(flexefy!) "part"
comment:
(003) "eqv?" ## (002) "car" "part"
(002) "string->symbol" (002) "list->string" (003) "append" (003) "list" ## #\ (002) "cdr" "part"
 
(flexefy!) "part"
comment:
#true
(zedefy) (002) "list->string" "part"
 
(function) "expression"
comment:
#true
(002) "caar" "expression"
 
(function-sort) "sentences"
comment:
#true
(rd) nil "append" (sort) clause-less? (by-four) "sentences"
 
(functionize) "clause" "arity-hash"
comment:
#true
(004) "list" "'define" (003) "cons" (clause-name) "clause" (clause-arguments) "clause" (003) "cons" "'cond" (003) "append" (condefy) (map-with) schemefy (clause-body) "clause" "arity-hash" (002) "list" (003) "list" "'else" "'ZEDerr"
 
(gather-count?) "symbol"
comment:
#true
(gather-count?!) (002) "string->list" (002) "symbol->string" "symbol"
 
(gather-count?!) "candidate"
comment:
#true
(008) "and" (003) "=" 6 (002) "length" "candidate" (003) "eqv?" #Z (002) "car" "candidate" (003) "eqv?" #E (002) "cadr" "candidate" (003) "eqv?" #D (002) "caddr" "candidate" (003) "eqv?" #0 (002) "cadddr" "candidate" (digit?) (002) "car" (002) "cddddr" "candidate" (digit?) (002) "cadr" (002) "cddddr" "candidate"
 
(gather-noun) "sentence"
comment:
(002) "null?" "sentence"
nil
 
(gather-noun) "sentence"
comment:
(003) "eqv?" #space (002) "car" "sentence"
nil
 
(gather-noun) "sentence"
comment:
#true
(003) "cons" (002) "car" "sentence" (gather-noun) (002) "cdr" "sentence"
 
(gather-verb) "sentence"
comment:
(003) "eqv?" #) (002) "car" "sentence"
nil
 
(gather-verb) "sentence"
comment:
#true
(003) "cons" (002) "car" "sentence" (gather-verb) (002) "cdr" "sentence"
 
(gr) "garbage" "value"
comment:
#true
(003) "begin" (dr) "garbage" "value"
 
(grr) "garbage" "value"
comment:
#true
(003) "begin" (drr) "garbage" "value"
 
(leading-newline) "program"
comment:
(002) "null?" "program"
nil
 
(leading-newline) "program"
comment:
(003) "eqv?" #newline (002) "car" "program"
(002) "cdr" "program"
 
(leading-newline) "program"
comment:
#true
"program"
 
(map-with) "function" "list" "extra"
comment:
#true
(002) "reverse" (map-with!) "function" "list" "extra" nil
 
(map-with!) "function" "list" "extra" "collect"
comment:
(002) "null?" "list"
"collect"
 
(map-with!) "function" "list" "extra" "collect"
comment:
#true
(map-with!) "function" (002) "cdr" "list" "extra" (003) "cons" (003) "function" (002) "car" "list" "extra" "collect"
 
(merge) "comparator" "list1" "list2"
comment:
#true
(merge!) "comparator" "list1" "list2" nil
 
(merge!) "comparator" "list1" "list2" "collect"
comment:
(002) "null?" "list2"
(003) "append" (002) "reverse" "collect" "list1"
 
(merge!) "comparator" "list1" "list2" "collect"
comment:
(002) "null?" "list1"
(003) "append" (002) "reverse" "collect" "list2"
 
(merge!) "comparator" "list1" "list2" "collect"
comment:
(003) "comparator" (002) "car" "list2" (002) "car" "list1"
(merge!) "comparator" "list1" (002) "cdr" "list2" (003) "cons" (002) "car" "list2" "collect"
 
(merge!) "comparator" "list1" "list2" "collect"
comment:
#true
(merge!) "comparator" (002) "cdr" "list1" "list2" (003) "cons" (002) "car" "list1" "collect"
 
(mp) "function" "list"
comment:
(002) "null?" "list"
nil
 
(mp) "function" "list"
comment:
(002) "pair?" "list"
(c) (002) "function" (1) "list" (mp) "function" (!) "list"
 
(mp) "function" "list"
comment:
#true
(002) "function" "list"
 
(namefy) "part"
comment:
(002) "pair?" "part"
(002) "list" (symbolize) (002) "car" "part"
 
(namefy) "part"
comment:
#true
(flexefy) "part"
 
(newline-space) "program"
comment:
#true
(newline-space!) "program"
 
(newline-space!) "program"
comment:
#true
(003) "cons" #newline (newline-space!a) "program"
 
(newline-space!a) "program"
comment:
#true
(newline-space!aa) "program" (002) "reverse" (newline-space!ab) "program" nil
 
(newline-space!aa) "program" "transformed"
comment:
(003) "equal?" "program" "transformed"
"program"
 
(newline-space!aa) "program" "transformed"
comment:
#true
(newline-space!a) "transformed"
 
(newline-space-tab-repeats) "program"
comment:
#true
(002) "reverse" (newline-space-tab-repeats!) "program" nil
 
(newline-space-tab-repeats!) "program" "collect"
comment:
(003) "or" (002) "null?" "program" (002) "null?" (002) "cdr" "program"
(003) "append" "program" "collect"
 
(newline-space-tab-repeats!) "program" "collect"
comment:
(003) "and" (003) "eqv?" #newline (002) "car" "program" (003) "eqv?" #newline (002) "cadr" "program"
(newline-space-tab-repeats!) (002) "cdr" "program" "collect"
 
(newline-space-tab-repeats!) "program" "collect"
comment:
(003) "and" (003) "or" (003) "eqv?" #space (002) "car" "program" (003) "eqv?" #tab (002) "car" "program" (003) "or" (003) "eqv?" #space (002) "cadr" "program" (003) "eqv?" #tab (002) "cadr" "program"
(newline-space-tab-repeats!) (002) "cdr" "program" "collect"
 
(newline-space-tab-repeats!) "program" "collect"
comment:
#true
(newline-space-tab-repeats!) (002) "cdr" "program" (003) "cons" (002) "car" "program" "collect"
 
(newline-space!ab) "program" "collect"
comment:
(002) "null?" "program"
"collect"
 
(newline-space!ab) "program" "collect"
comment:
(002) "null?" (002) "cdr" "program"
(003) "cons" (002) "car" "program" "collect"
 
(newline-space!ab) "program" "collect"
comment:
(003) "and" (003) "eqv?" #newline (002) "car" "program" (003) "or" (003) "eqv?" #space (002) "cadr" "program" (003) "eqv?" #tab (002) "cadr" "program"
(newline-space!ab) (002) "cdr" "program" "collect"
 
(newline-space!ab) "program" "collect"
comment:
#true
(newline-space!ab) (002) "cdr" "program" (003) "cons" (002) "car" "program" "collect"
 
(newlines) "clauses"
comment:
#true
(add-between-ra) (map-with) add-between-ra "clauses" (002) "list" #newline (003) "list" #newline #newline
 
(not-return?) "character"
comment:
#true
(002) "not" (003) "eqv?" #return "character"
 
(noun) "gather-noun"
comment:
#true
(noun!) (002) "list->string" "gather-noun"
 
(noun-number) "string" "number"
comment:
#true
(noun-number!) "string" (002) "string->list" "string" "number"
 
(noun-number!) "string" "list" "number"
comment:
"number"
"number"
 
(noun-number!) "string" "list" "number"
comment:
#true
(noun-number!a) "string" "list" (002) "reverse" "list"
 
(noun-number!a) "string" "list" "reversed"
comment:
(003) "and" (003) "eqv?" #" (002) "car" "list" (003) "eqv?" #" (002) "car" "reversed"
(002) "list->string" (002) "cdr" (002) "reverse" (002) "cdr" "reversed"
 
(noun-number!a) "string" "list" "reversed"
comment:
#true
(002) "string->symbol" "string"
 
(noun!) "string"
comment:
#true
(noun-number) "string" (002) "string->number" "string"
 
(pop) "stack"
comment:
#true
(002) "cdr" "stack"
 
(pr) "value"
comment:
#true
(pr!) "value" (001) "open-output-string"
 
(pr!) "value" "output-string"
comment:
#true
(003) "begin" (003) "display" (pr!a) "value" nil "output-string" (002) "get-output-string" "output-string"
 
(pr!a) "value" "collect"
comment:
(002) "char?" "value"
(002) "list->string" (003) "list" ## "value"
 
(pr!a) "value" "collect"
comment:
(002) "string?" "value"
(004) "string-append" ""\""" "value" ""\"""
 
(pr!a) "value" "collect"
comment:
(002) "null?" "value"
(002) "reverse" "collect"
 
(pr!a) "value" "collect"
comment:
(002) "not" (002) "pair?" "value"
"value"
 
(pr!a) "value" "collect"
comment:
#true
(pr!a) (!) "value" (003) "cons" (pr!a) (1) "value" "collect"
 
(primitives)
comment:
#true
(002) "quote" (008) "begin" (003) "define-macro" (003) or "a" "b" (002) "quasiquote" (003) "or" (002) "unquote" "a" (002) "unquote" "b" (003) "define-macro" (003) and "a" "b" (002) "quasiquote" (003) "and" (002) "unquote" "a" (002) "unquote" "b" (003) "define-macro" (003) se "a" "b" (002) "quasiquote" (003) "begin" (002) "unquote" "a" (002) "unquote" "b" (003) "define-macro" (003) c "a" "b" (002) "quasiquote" (003) "cons" (002) "delay" (002) "unquote" "a" (002) "delay" (002) "unquote" "b" (003) "define-macro" (002) quote "a" (002) "quasiquote" (002) "unquote" "a" (003) "define" err "'err" (003) "define" nil "'()"
 
(programize) "program" "arity-hash"
comment:
#true
(003) "cons" "'begin" (map-with) functionize "program" "arity-hash"
 
(push) "object" "stack"
comment:
#true
(003) "cons" "object" "stack"
 
(rd) "final" "function" "list"
comment:
#true
(rd!) "function" (003) "cons" "final" (002) "reverse" "list"
 
(rd!) "function" "list"
comment:
(002) "null?" (!) "list"
(1) "list"
 
(rd!) "function" "list"
comment:
#true
(rd!) "function" (003) "cons" (003) "function" (2) "list" (1) "list" (-2) "list"
 
(read-all)
comment:
#true
(002) "reverse" (read-all!) nil
 
(read-all!) "collect"
comment:
#true
(read-all!a) (001) "read-char" "collect"
 
(read-all!a) "character" "collect"
comment:
(002) "eof-object?" "character"
"collect"
 
(read-all!a) "character" "collect"
comment:
#true
(read-all!) (003) "cons" "character" "collect"
 
(read-sentence) "sentence"
comment:
#true
(002) "reverse" (read-sentence!) "sentence" nil
 
(read-sentence!) "sentence" "collect"
comment:
(002) "null?" "sentence"
"collect"
 
(read-sentence!) "sentence" "collect"
comment:
(003) "eqv?" #space (002) "car" "sentence"
(read-sentence!) (002) "cdr" "sentence" "collect"
 
(read-sentence!) "sentence" "collect"
comment:
(003) "eqv?" #( (002) "car" "sentence"
(read-sentence!a) "sentence" (gather-verb) (002) "cdr" "sentence" "collect"
 
(read-sentence!) "sentence" "collect"
comment:
#true
(read-sentence!b) "sentence" (gather-noun) "sentence" "collect"
 
(read-sentence!a) "sentence" "gather-verb" "collect"
comment:
#true 
(read-sentence!) (tails) 
                   (003) "+" 2 (002) "length" 
                                     "gather-verb" 
                   "sentence" 
                 (003) "cons"
                       (namefy)
                         (002) "list" 
                               (verb) "gather-verb" 
                       "collect"
 
(read-sentence!b) "sentence" "gather-noun" "collect"
comment:
#true
(read-sentence!) (tails) (002) "length" "gather-noun" 
                         "sentence" 
                 (003) "cons" (namefy) 
                                (noun) "gather-noun"  
                              "collect"
 
(read-sentences) "sentences"
comment:
#true
(read-sentences!) "sentences" nil
 
(read-sentences!) "sentences" "collect"
comment:
#true
(003) "map" "reverse" (map-with) read-sentence! "sentences" "collect"
 
(ready-clause) "clause"
comment:
#true
(003) "cons" (002) "caaar" "clause" (003) "cons" (002) "cdar" "clause" (002) "cdr" "clause"
 
(ready-program) "program"
comment:
#true
(003) "map" ready-clause "program"
 
(schemefy) "expression" "arity-hash"
comment:
#true
(002) "list" (schemefy!) (002) "reverse" "expression" "arity-hash" (stack)
 
(schemefy!) "expression" "arity-hash" "stack"
comment:
(002) "zero?" (002) "length" "expression"
(top) "stack"
 
(schemefy!) "expression" "arity-hash" "stack"
comment:
(002) "not" (application?) "expression"
(schemefy!) (pop) "expression" "arity-hash" (push) (top) "expression" "stack"
 
(schemefy!) "expression" "arity-hash" "stack"
comment:
#true
(schemefy!a) "expression" "arity-hash" "stack" (function) "expression"
 
(schemefy!a) "expression" "arity-hash" "stack" "function"
comment:
#true
(schemefy!aa) "expression" "arity-hash" "stack" "function" (arity) "arity-hash" "function"
 
(schemefy!aa) "expression" "arity-hash" "stack" "function" "arity"
comment:
(gather-count?) "function"
(schemefy!) (pop) "expression" "arity-hash" (push) (zed->scheme) (first) "arity" "stack" (zed->scheme) (tails) "arity" "stack"
 
(schemefy!aa) "expression" "arity-hash" "stack" "function" "arity"
comment:
#true
(schemefy!) (pop) "expression" "arity-hash" (push) (push) "function" (zed->scheme) (first) "arity" "stack" (zed->scheme) (tails) "arity" "stack"
 
(sentence-less?) "sentence1" "sentence2"
comment:
(002) "null?" "sentence2"
"#f"
 
(sentence-less?) "sentence1" "sentence2"
comment:
(002) "null?" "sentence1"
"#t"
 
(sentence-less?) "sentence1" "sentence2"
comment:
(character-less?) (002) "car" "sentence1" (002) "car" "sentence2"
"#t"
 
(sentence-less?) "sentence1" "sentence2"
comment:
(character-less?) (002) "car" "sentence2" (002) "car" "sentence1"
"#f"
 
(sentence-less?) "sentence1" "sentence2"
comment:
#true
(sentence-less?) (002) "cdr" "sentence1" (002) "cdr" "sentence2"
 
(sentences) "program"
comment:
#true
(002) "reverse" (sentences!) "program" nil nil
 
(sentences!) "program" "collect1" "collect2"
comment:
(002) "null?" "program"
"collect2"
 
(sentences!) "program" "collect1" "collect2"
comment:
(003) "eqv?" #newline (002) "car" "program"
(sentences!) (002) "cdr" "program" nil (003) "cons" (002) "reverse" "collect1" "collect2"
 
(sentences!) "program" "collect1" "collect2"
comment:
#true
(sentences!) (002) "cdr" "program" (003) "cons" (002) "car" "program" "collect1" "collect2"
 
(slashefy) "character"
comment:
(003) "eqv?" #" "character"
(003) "list" #\ #"
 
(slashefy) "character"
comment:
(003) "eqv?" #\ "character"
(003) "list" #\ #\
 
(slashefy) "character"
comment:
#true
(002) "list" "character"
 
(sort) "comparator" "jumble"
comment:
#true
(002) "car" (sort!b) "comparator" (sort!a) "jumble"
 
(sort!a) "jumble"
comment:
#true
(003) "map" "list" "jumble"
 
(sort!b) "comparator" "jumble"
comment:
(002) "null?" "jumble"
nil
 
(sort!b) "comparator" "jumble"
comment:
(002) "null?" (002) "cdr" "jumble"
"jumble"
 
(sort!b) "comparator" "jumble"
comment:
#true
(sort!b) "comparator" (003) "cons" (merge) "comparator" (002) "car" "jumble" (002) "cadr" "jumble" (sort!b) "comparator" (002) "cddr" "jumble"
 
(space-newline) "program"
comment:
#true
(002) "reverse" (space-newline!) "program" nil

(space-newline!) "program" "collect"
comment:
(003) "or" (002) "null?" "program" (002) "null?" (002) "cdr" "program"
(003) "append" "program" "collect"
 
(space-newline!) "program" "collect"
comment:
(003) "and" (003) "eqv?" #space (002) "car" "program" (003) "eqv?" #newline (002) "cadr" "program"
(space-newline!) (002) "cdr" "program" "collect"
 
(space-newline!) "program" "collect"
comment:
#true
(space-newline!) (002) "cdr" "program" (003) "cons" (002) "car" "program" "collect"
 
(stack)
comment:
#true
nil
 
(symbol-character) "character"
comment:
(003) "char=?" "character" #@
(003) "list" #@ #@
 
(symbol-character) "character"
comment:
(003) "char=?" "character" #[
(003) "list" #@ #1
 
(symbol-character) "character"
comment:
(003) "char=?" "character" #]
(003) "list" #@ #2
 
(symbol-character) "character"
comment:
(003) "char=?" "character" #{
(003) "list" #@ #3
 
(symbol-character) "character"
comment:
(003) "char=?" "character" #}
(003) "list" #@ #4
 
(symbol-character) "character"
comment:
(003) "char=?" "character" #'
(003) "list" #@ #q
 
(symbol-character) "character"
comment:
(003) "char=?" "character" #`
(003) "list" #@ #Q
 
(symbol-character) "character"
comment:
(003) "char=?" "character" #,
(003) "list" #@ #c
 
(symbol-character) "character"
comment:
(003) "char=?" "character" #:
(003) "list" #@ #C
 
(symbol-character) "character"
comment:
(003) "char=?" "character" #;
(003) "list" #@ #s
 
(symbol-character) "character"
comment:
(003) "char=?" "character" #\
(003) "list" #@ #b
 
(symbol-character) "character"
comment:
#true
(002) "list" "character"
 
(symbolize) "part"
comment:
(002) "symbol?" "part"
(zedefy) (002) "symbol->string" "part"
 
(symbolize) "part"
comment:
#true
(002) "string->symbol" "part"
 
(tab-replace) "program"
comment:
#true
(002) "reverse" (tab-replace!) "program" nil
 
(tab-replace!) "program" "collect"
comment:
(002) "null?" "program"
"collect"
 
(tab-replace!) "program" "collect"
comment:
(003) "eqv?" #tab (002) "car" "program"
(tab-replace!) (002) "cdr" "program" (003) "cons" #space "collect"
 
(tab-replace!) "program" "collect"
comment:
#true
(tab-replace!) (002) "cdr" "program" (003) "cons" (002) "car" "program" "collect"
 
(tails) "number" "list"
comment:
(002) "null?" "list"
nil
 
(tails) "number" "list"
comment:
(002) "zero?" "number"
"list"
 
(tails) "number" "list"
comment:
(003) ">" "number" 0
(tails) (003) "-" "number" 1 (002) "cdr" "list"
 
(top) "stack"
comment:
#true
(002) "car" "stack"
 
(verb) "gather-verb"
comment:
(004) "and" (002) "not" (002) "null?" (002) "cdr" "gather-verb" (003) "eqv?" #" (002) "car" "gather-verb" (003) "eqv?" #" (002) "car" (002) "reverse" "gather-verb"
(002) "list->string" (002) "cdr" (002) "reverse" (002) "cdr" (002) "reverse" "gather-verb"
 
(verb) "gather-verb"
comment:
#true
(002) "string->symbol" (002) "list->string" "gather-verb"
 
(write-all) "program"
comment:
(002) "null?" "program"
err
 
(write-all) "program"
comment:
#true
(write-all) (003) "begin" (002) "write-char" (002) "car" "program" (002) "cdr" "program"
 
(zed->scheme) "value"
comment:
(002) "not" (002) "pair?" "value"
"value"
 
(zed->scheme) "value"
comment:
#true
(zed->scheme!) "value" nil
 
(zed->scheme!) "value" "collect"
comment:
(002) "null?" "value"
(002) "reverse" "collect"
 
(zed->scheme!) "value" "collect"
comment:
#true
(zed->scheme!) (!) "value" (003) "cons" (zed->scheme) (1) "value" "collect"
 
(zedefy) "string"
comment:
#true
(002) "string->symbol" (002) "list->string" (003) "append" (004) "list" #Z #E #D (flatten) (003) "map" symbol-character (002) "string->list" "string"
