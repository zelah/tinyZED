(begin (define-macro (ZEDor a b) `(or ,a ,b)) (define-macro (ZEDand a b) `(and ,a ,b)) (define-macro (ZEDse a b) `(begin ,a ,b)) (define-macro (ZEDc a b) `(cons (delay ,a) (delay ,b))) (define-macro (ZEDquote a) `,a) (define ZEDalways #t) (define ZEDerr 'err) (define ZEDnil '()))
(begin (define (ZED! pair) (cond (#t (ZEDforce! (cdr pair))) (else ZEDerr))) (define (ZED-2 list) (cond (#t (ZED! (ZED! list))) (else ZEDerr))) (define (ZED1 pair) (cond (#t (ZEDforce! (car pair))) (else ZEDerr))) (define (ZED2 list) (cond (#t (ZED1 (ZED! list))) (else ZEDerr))) (define (ZED= value1 value2) (cond (#t (eqv? value1 value2)) (else ZEDerr))) (define (ZEDadd-between! item list collect) (cond ((null? list) collect) ((null? (cdr list)) (cons (car list) collect)) (#t (ZEDadd-between! item (cdr list) (cons item (cons (car list) collect)))) (else ZEDerr))) (define (ZEDadd-between item list) (cond (#t (reverse (ZEDadd-between! item list ZEDnil))) (else ZEDerr))) (define (ZEDadd-between-ra list item) (cond (#t (reverse (ZEDadd-between! item list ZEDnil))) (else ZEDerr))) (define (ZEDalpha) (cond (#t (ZEDwrite-all (ZEDflatten (ZEDnewlines (ZEDby-four (ZEDfunction-sort (ZEDsentences (ZEDleading-newline (ZEDspace-newline (ZEDtab-replace (ZEDnewline-space-tab-repeats (ZEDnewline-space (ZEDfilter ZEDnot-return? (ZEDread-all)))))))))))))) (else ZEDerr))) (define (ZEDapplication? expression) (cond (#t (and (not (null? expression)) (pair? (car expression)))) (else ZEDerr))) (define (ZEDarity arity-hash function) (cond (#t (cdr (assoc function arity-hash))) (else ZEDerr))) (define (ZEDarity-hash! clause) (cond (#t (cons (ZEDclause-name clause) (ZEDclause-arity clause))) (else ZEDerr))) (define (ZEDarity-hash program) (cond (#t (append (map ZEDarity-hash! program) (append (list (cons 'ZED001 1) (cons 'ZEDor 2) (cons 'ZEDand 2) (cons 'ZEDse 2) (cons 'ZEDc 2) (cons 'ZEDquote 1)) (list (cons 'ZED002 2) (cons 'ZED003 3) (cons 'ZED004 4) (cons 'ZED005 5) (cons 'ZED006 6) (cons 'ZED007 7) (cons 'ZED008 8) (cons 'ZED009 9) (cons 'ZED010 10) (cons 'ZED011 11) (cons 'ZED012 12) (cons 'ZED013 13) (cons 'ZED014 14) (cons 'ZED015 15) (cons 'ZED016 16) (cons 'ZED017 17) (cons 'ZED018 18) (cons 'ZED019 19) (cons 'ZED020 20) (cons 'ZED021 21) (cons 'ZED022 22) (cons 'ZED023 23) (cons 'ZED024 24) (cons 'ZED025 25) (cons 'ZED026 26) (cons 'ZED027 27) (cons 'ZED028 28) (cons 'ZED029 29) (cons 'ZED030 30) (cons 'ZED031 31) (cons 'ZED032 32) (cons 'ZED033 33) (cons 'ZED034 34) (cons 'ZED035 35) (cons 'ZED036 36) (cons 'ZED037 37) (cons 'ZED038 38) (cons 'ZED039 39) (cons 'ZED040 40) (cons 'ZED041 41) (cons 'ZED042 42) (cons 'ZED043 43) (cons 'ZED044 44) (cons 'ZED045 45) (cons 'ZED046 46) (cons 'ZED047 47) (cons 'ZED048 48) (cons 'ZED049 49) (cons 'ZED050 50) (cons 'ZED051 51) (cons 'ZED052 52) (cons 'ZED053 53) (cons 'ZED054 54) (cons 'ZED055 55) (cons 'ZED056 56) (cons 'ZED057 57) (cons 'ZED058 58) (cons 'ZED059 59) (cons 'ZED060 60) (cons 'ZED061 61) (cons 'ZED062 62) (cons 'ZED063 63) (cons 'ZED064 64) (cons 'ZED065 65) (cons 'ZED066 66) (cons 'ZED067 67) (cons 'ZED068 68) (cons 'ZED069 69) (cons 'ZED070 70) (cons 'ZED071 71) (cons 'ZED072 72) (cons 'ZED073 73) (cons 'ZED074 74) (cons 'ZED075 75) (cons 'ZED076 76) (cons 'ZED077 77) (cons 'ZED078 78) (cons 'ZED079 79) (cons 'ZED080 80) (cons 'ZED081 81) (cons 'ZED082 82) (cons 'ZED083 83) (cons 'ZED084 84) (cons 'ZED085 85) (cons 'ZED086 86) (cons 'ZED087 87) (cons 'ZED088 88) (cons 'ZED089 89) (cons 'ZED090 90) (cons 'ZED091 91) (cons 'ZED092 92) (cons 'ZED093 93) (cons 'ZED094 94) (cons 'ZED095 95) (cons 'ZED096 96) (cons 'ZED097 97) (cons 'ZED098 98) (cons 'ZED099 99))))) (else ZEDerr))) (define (ZEDby-four! sentences collect) (cond ((null? sentences) collect) (#t (ZEDby-four! (cddddr sentences) (cons (list (car sentences) (cadr sentences) (caddr sentences) (cadddr sentences)) collect))) (else ZEDerr))) (define (ZEDby-four sentences) (cond (#t (reverse (ZEDby-four! sentences ZEDnil))) (else ZEDerr))) (define (ZEDby-three! sentences collect) (cond ((null? sentences) collect) (#t (ZEDby-three! (cdddr sentences) (cons (list (car sentences) (cadr sentences) (caddr sentences)) collect))) (else ZEDerr))) (define (ZEDby-three sentences) (cond (#t (reverse (ZEDby-three! sentences ZEDnil))) (else ZEDerr))) (define (ZEDcharacter-less? character1 character2) (cond (#t (< (char->integer character1) (char->integer character2))) (else ZEDerr))) (define (ZEDclause-arguments clause) (cond (#t (cadr clause)) (else ZEDerr))) (define (ZEDclause-arguments-agree clause1 clause2) (cond ((equal? (ZEDclause-arguments clause1) (ZEDclause-arguments clause2)) (ZEDclause-arguments clause1)) (else ZEDerr))) (define (ZEDclause-arity clause) (cond (#t (length (ZEDclause-arguments clause))) (else ZEDerr))) (define (ZEDclause-body clause) (cond (#t (cddr clause)) (else ZEDerr))) (define (ZEDclause-less? clause1 clause2) (cond (#t (ZEDsentence-less? (car clause1) (car clause2))) (else ZEDerr))) (define (ZEDclause-name clause) (cond (#t (car clause)) (else ZEDerr))) (define (ZEDclause-name-agree clause1 clause2) (cond ((eq? (ZEDclause-name clause1) (ZEDclause-name clause2)) (ZEDclause-name clause1)) (else ZEDerr))) (define (ZEDcombine-all! program collect) (cond ((null? program) collect) ((null? (cdr program)) (cons (car program) collect)) ((eq? (ZEDclause-name (car program)) (ZEDclause-name (cadr program))) (ZEDcombine-all! (ZEDcombine-head-clauses program) collect)) (#t (ZEDcombine-all! (cdr program) (cons (car program) collect))) (else ZEDerr))) (define (ZEDcombine-all program) (cond (#t (reverse (ZEDcombine-all! program ZEDnil))) (else ZEDerr))) (define (ZEDcombine-clauses clause1 clause2) (cond (#t (cons (ZEDclause-name-agree clause1 clause2) (cons (ZEDclause-arguments-agree clause1 clause2) (append (ZEDclause-body clause1) (ZEDclause-body clause2))))) (else ZEDerr))) (define (ZEDcombine-head-clauses program) (cond (#t (cons (ZEDcombine-clauses (car program) (cadr program)) (cddr program))) (else ZEDerr))) (define (ZEDcombine-program-clauses program) (cond (#t (ZEDcombine-all (ZEDready-program program))) (else ZEDerr))) (define (ZEDcomp!) (cond (#t (ZEDcomp!a (ZEDgr "(combine-program-clauses)" (ZEDcombine-program-clauses (ZEDgr "(by-three)" (ZEDby-three (ZEDgr "(read-sentences)" (ZEDread-sentences (ZEDgr "(discard-comments)" (ZEDdiscard-comments (ZEDgr "(function-sort)" (ZEDfunction-sort (ZEDgr "(sentences)" (ZEDsentences (ZEDgr "(leading-newline)" (ZEDleading-newline (ZEDgr "(space-newline)" (ZEDspace-newline (ZEDgr "(tab-replace)" (ZEDtab-replace (ZEDgr "(newline-space-tab-repeats)" (ZEDnewline-space-tab-repeats (ZEDgr "(newline-space)" (ZEDnewline-space (ZEDgr "(filter)" (ZEDfilter ZEDnot-return? (ZEDgr "(read-all)" (ZEDread-all)))))))))))))))))))))))))))) (else ZEDerr))) (define (ZEDcomp!a combined) (cond (#t (ZEDcomp!aa (ZEDprogramize combined (ZEDarity-hash combined)))) (else ZEDerr))) (define (ZEDcomp!aa programized) (cond (#t (begin (display (ZEDprimitives)) (newline) (display programized))) (else ZEDerr))) (define (ZEDcomp) (cond (#t (ZEDcomp!)) (else ZEDerr))) (define (ZEDcondefy! expressions collect) (cond ((null? expressions) collect) (#t (ZEDcondefy! (cddr expressions) (cons (append (car expressions) (cadr expressions)) collect))) (else ZEDerr))) (define (ZEDcondefy expressions) (cond (#t (reverse (ZEDcondefy! expressions ZEDnil))) (else ZEDerr))) (define (ZEDdigit? character) (cond (#t (or (eqv? #\0 character) (eqv? #\1 character) (eqv? #\2 character) (eqv? #\3 character) (eqv? #\4 character) (eqv? #\5 character) (eqv? #\6 character) (eqv? #\7 character) (eqv? #\8 character) (eqv? #\9 character))) (else ZEDerr))) (define (ZEDdiscard-comments! program collect) (cond ((null? program) collect) (#t (ZEDdiscard-comments! (cddddr program) (cons (cadddr program) (cons (caddr program) (cons (car program) collect))))) (else ZEDerr))) (define (ZEDdiscard-comments program) (cond (#t (reverse (ZEDdiscard-comments! program ZEDnil))) (else ZEDerr))) (define (ZEDdr! value) (cond ((pair? value) (ZEDmp ZEDdr! (ZEDfirst 64 value))) (#t value) (else ZEDerr))) (define (ZEDdr value) (cond (#t (begin (display (ZEDpr (ZEDdr! value))) (newline) (newline) value)) (else ZEDerr))) (define (ZEDdrr value) (cond (#t (begin (display (ZEDpr value)) (newline) (newline) value)) (else ZEDerr))) (define (ZEDfi function list) (cond ((null? list) ZEDnil) ((function (ZED1 list)) (ZEDc (ZED1 list) (ZEDfi function (ZED! list)))) (#t (ZEDfi function (ZED! list))) (else ZEDerr))) (define (ZEDfilter! predicate list collect) (cond ((null? list) collect) ((predicate (car list)) (ZEDfilter! predicate (cdr list) (cons (car list) collect))) (#t (ZEDfilter! predicate (cdr list) collect)) (else ZEDerr))) (define (ZEDfilter predicate list) (cond (#t (reverse (ZEDfilter! predicate list ZEDnil))) (else ZEDerr))) (define (ZEDfirst! integer list collect) (cond ((or (zero? integer) (null? list)) (reverse collect)) ((> integer 0) (ZEDfirst! (- integer 1) (ZED! list) (cons (ZED1 list) collect))) (else ZEDerr))) (define (ZEDfirst integer list) (cond ((not (pair? list)) list) (#t (ZEDfirst! integer list ZEDnil)) (else ZEDerr))) (define (ZEDflatten! object collect) (cond ((null? object) collect) ((not (pair? object)) (cons object collect)) (#t (ZEDflatten! (car object) (append (ZEDflatten! (cdr object) collect)))) (else ZEDerr))) (define (ZEDflatten object) (cond (#t (ZEDflatten! object ZEDnil)) (else ZEDerr))) (define (ZEDflexefy! part) (cond ((equal? part (list #\# #\t #\r #\u #\e)) #t) ((equal? part (list #\# #\f #\a #\l #\s #\e)) #f) ((eqv? #\# (car part)) (string->symbol (list->string (append (list #\# #\\) (cdr part))))) (#t (ZEDzedefy (list->string part))) (else ZEDerr))) (define (ZEDflexefy part) (cond ((symbol? part) (ZEDflexefy! (string->list (symbol->string part)))) ((string? part) (string->symbol part)) ((exact? part) part) (#t (string->number (string-append "#e" (number->string part)))) (else ZEDerr))) (define (ZEDforce! value) (cond ((promise? value) (force value)) (#t value) (else ZEDerr))) (define (ZEDfunction expression) (cond (#t (caar expression)) (else ZEDerr))) (define (ZEDfunction-sort sentences) (cond (#t (ZEDrd ZEDnil append (ZEDsort ZEDclause-less? (ZEDby-four sentences)))) (else ZEDerr))) (define (ZEDfunctionize clause arity-hash) (cond (#t (list 'define (cons (ZEDclause-name clause) (ZEDclause-arguments clause)) (cons 'cond (append (ZEDcondefy (ZEDmap-with ZEDschemefy (ZEDclause-body clause) arity-hash)) (list (list 'else 'ZEDerr)))))) (else ZEDerr))) (define (ZEDgather-count?! candidate) (cond (#t (and (= 6 (length candidate)) (eqv? #\Z (car candidate)) (eqv? #\E (cadr candidate)) (eqv? #\D (caddr candidate)) (eqv? #\0 (cadddr candidate)) (ZEDdigit? (car (cddddr candidate))) (ZEDdigit? (cadr (cddddr candidate))))) (else ZEDerr))) (define (ZEDgather-count? symbol) (cond (#t (ZEDgather-count?! (string->list (symbol->string symbol)))) (else ZEDerr))) (define (ZEDgather-noun sentence) (cond ((null? sentence) ZEDnil) ((eqv? #\space (car sentence)) ZEDnil) (#t (cons (car sentence) (ZEDgather-noun (cdr sentence)))) (else ZEDerr))) (define (ZEDgather-verb sentence) (cond ((eqv? #\) (car sentence)) ZEDnil) (#t (cons (car sentence) (ZEDgather-verb (cdr sentence)))) (else ZEDerr))) (define (ZEDgr garbage value) (cond (#t (begin (ZEDdr garbage) value)) (else ZEDerr))) (define (ZEDgrr garbage value) (cond (#t (begin (ZEDdrr garbage) value)) (else ZEDerr))) (define (ZEDid x) (cond (#t x) (else ZEDerr))) (define (ZEDleading-newline program) (cond ((null? program) ZEDnil) ((eqv? #\newline (car program)) (cdr program)) (#t program) (else ZEDerr))) (define (ZEDmap-with! function list extra collect) (cond ((null? list) collect) (#t (ZEDmap-with! function (cdr list) extra (cons (function (car list) extra) collect))) (else ZEDerr))) (define (ZEDmap-with function list extra) (cond (#t (reverse (ZEDmap-with! function list extra ZEDnil))) (else ZEDerr))) (define (ZEDmerge! comparator list1 list2 collect) (cond ((null? list2) (append (reverse collect) list1)) ((null? list1) (append (reverse collect) list2)) ((comparator (car list2) (car list1)) (ZEDmerge! comparator list1 (cdr list2) (cons (car list2) collect))) (#t (ZEDmerge! comparator (cdr list1) list2 (cons (car list1) collect))) (else ZEDerr))) (define (ZEDmerge comparator list1 list2) (cond (#t (ZEDmerge! comparator list1 list2 ZEDnil)) (else ZEDerr))) (define (ZEDmp function list) (cond ((null? list) ZEDnil) ((pair? list) (ZEDc (function (ZED1 list)) (ZEDmp function (ZED! list)))) (#t (function list)) (else ZEDerr))) (define (ZEDnamefy part) (cond ((pair? part) (list (ZEDsymbolize (car part)))) (#t (ZEDflexefy part)) (else ZEDerr))) (define (ZEDnewline-space! program) (cond (#t (cons #\newline (ZEDnewline-space!a program))) (else ZEDerr))) (define (ZEDnewline-space!a program) (cond (#t (ZEDnewline-space!aa program (reverse (ZEDnewline-space!ab program ZEDnil)))) (else ZEDerr))) (define (ZEDnewline-space!aa program transformed) (cond ((equal? program transformed) program) (#t (ZEDnewline-space!a transformed)) (else ZEDerr))) (define (ZEDnewline-space!ab program collect) (cond ((null? program) collect) ((null? (cdr program)) (cons (car program) collect)) ((and (eqv? #\newline (car program)) (or (eqv? #\space (cadr program)) (eqv? #\tab (cadr program)))) (ZEDnewline-space!ab (cdr program) collect)) (#t (ZEDnewline-space!ab (cdr program) (cons (car program) collect))) (else ZEDerr))) (define (ZEDnewline-space program) (cond (#t (ZEDnewline-space! program)) (else ZEDerr))) (define (ZEDnewline-space-tab-repeats! program collect) (cond ((or (null? program) (null? (cdr program))) (append program collect)) ((and (eqv? #\newline (car program)) (eqv? #\newline (cadr program))) (ZEDnewline-space-tab-repeats! (cdr program) collect)) ((and (or (eqv? #\space (car program)) (eqv? #\tab (car program))) (or (eqv? #\space (cadr program)) (eqv? #\tab (cadr program)))) (ZEDnewline-space-tab-repeats! (cdr program) collect)) (#t (ZEDnewline-space-tab-repeats! (cdr program) (cons (car program) collect))) (else ZEDerr))) (define (ZEDnewline-space-tab-repeats program) (cond (#t (reverse (ZEDnewline-space-tab-repeats! program ZEDnil))) (else ZEDerr))) (define (ZEDnewlines clauses) (cond (#t (ZEDadd-between-ra (ZEDmap-with ZEDadd-between-ra clauses (list #\newline)) (list #\newline #\newline))) (else ZEDerr))) (define (ZEDnot-return? character) (cond (#t (not (eqv? #\return character))) (else ZEDerr))) (define (ZEDnoun! string) (cond (#t (ZEDnoun-number string (string->number string))) (else ZEDerr))) (define (ZEDnoun gather-noun) (cond (#t (ZEDnoun! (list->string gather-noun))) (else ZEDerr))) (define (ZEDnoun-number! string list number) (cond (number number) (#t (ZEDnoun-number!a string list (reverse list))) (else ZEDerr))) (define (ZEDnoun-number!a string list reversed) (cond ((and (eqv? #\" (car list)) (eqv? #\" (car reversed))) (list->string (cdr (reverse (cdr reversed))))) (#t (string->symbol string)) (else ZEDerr))) (define (ZEDnoun-number string number) (cond (#t (ZEDnoun-number! string (string->list string) number)) (else ZEDerr))) (define (ZEDpop stack) (cond (#t (cdr stack)) (else ZEDerr))) (define (ZEDpr! value output-string) (cond (#t (begin (display (ZEDpr!a value ZEDnil) output-string) (get-output-string output-string))) (else ZEDerr))) (define (ZEDpr!a value collect) (cond ((char? value) (list->string (list #\# value))) ((string? value) (string-append "\"" value "\"")) ((null? value) (reverse collect)) ((not (pair? value)) value) (#t (ZEDpr!a (ZED! value) (cons (ZEDpr!a (ZED1 value) collect)))) (else ZEDerr))) (define (ZEDpr value) (cond (#t (ZEDpr! value (open-output-string))) (else ZEDerr))) (define (ZEDprimitives) (cond (#t '(begin (define-macro (ZEDor a b) `(or ,a ,b)) (define-macro (ZEDand a b) `(and ,a ,b)) (define-macro (ZEDse a b) `(begin ,a ,b)) (define-macro (ZEDc a b) `(cons (delay ,a) (delay ,b))) (define-macro (ZEDquote a) `,a) (define ZEDerr 'err) (define ZEDnil '()))) (else ZEDerr))) (define (ZEDprogramize program arity-hash) (cond (#t (cons 'begin (ZEDmap-with ZEDfunctionize program arity-hash))) (else ZEDerr))) (define (ZEDpush object stack) (cond (#t (cons object stack)) (else ZEDerr))) (define (ZEDrd! function list) (cond ((null? (ZED! list)) (ZED1 list)) (#t (ZEDrd! function (cons (function (ZED2 list) (ZED1 list)) (ZED-2 list)))) (else ZEDerr))) (define (ZEDrd final function list) (cond (#t (ZEDrd! function (cons final (reverse list)))) (else ZEDerr))) (define (ZEDread-all! collect) (cond (#t (ZEDread-all!a (read-char) collect)) (else ZEDerr))) (define (ZEDread-all!a character collect) (cond ((eof-object? character) collect) (#t (ZEDread-all! (cons character collect))) (else ZEDerr))) (define (ZEDread-all) (cond (#t (reverse (ZEDread-all! ZEDnil))) (else ZEDerr))) (define (ZEDread-sentence! sentence collect) (cond ((null? sentence) collect) ((eqv? #\space (car sentence)) (ZEDread-sentence! (cdr sentence) collect)) ((eqv? #\( (car sentence)) (ZEDread-sentence!a sentence (ZEDgather-verb (cdr sentence)) collect)) (#t (ZEDread-sentence!b sentence (ZEDgather-noun sentence) collect)) (else ZEDerr))) (define (ZEDread-sentence!a sentence gather-verb collect) (cond (#t (ZEDread-sentence! (ZEDtails (+ 2 (length gather-verb)) sentence) (cons (ZEDnamefy (list (ZEDverb gather-verb))) collect))) (else ZEDerr))) (define (ZEDread-sentence!b sentence gather-noun collect) (cond (#t (ZEDread-sentence! (ZEDtails (length gather-noun) sentence) (cons (ZEDnamefy (ZEDnoun gather-noun)) collect))) (else ZEDerr))) (define (ZEDread-sentence sentence) (cond (#t (reverse (ZEDread-sentence! sentence ZEDnil))) (else ZEDerr))) (define (ZEDread-sentences! sentences collect) (cond (#t (map reverse (ZEDmap-with ZEDread-sentence! sentences collect))) (else ZEDerr))) (define (ZEDread-sentences sentences) (cond (#t (ZEDread-sentences! sentences ZEDnil)) (else ZEDerr))) (define (ZEDready-clause clause) (cond (#t (cons (caaar clause) (cons (cdar clause) (cdr clause)))) (else ZEDerr))) (define (ZEDready-program program) (cond (#t (map ZEDready-clause program)) (else ZEDerr))) (define (ZEDschemefy! expression arity-hash stack) (cond ((zero? (length expression)) (ZEDtop stack)) ((not (ZEDapplication? expression)) (ZEDschemefy! (ZEDpop expression) arity-hash (ZEDpush (ZEDtop expression) stack))) (#t (ZEDschemefy!a expression arity-hash stack (ZEDfunction expression))) (else ZEDerr))) (define (ZEDschemefy!a expression arity-hash stack function) (cond (#t (ZEDschemefy!aa expression arity-hash stack function (ZEDarity arity-hash function))) (else ZEDerr))) (define (ZEDschemefy!aa expression arity-hash stack function arity) (cond ((ZEDgather-count? function) (ZEDschemefy! (ZEDpop expression) arity-hash (ZEDpush (ZEDzed->scheme (ZEDfirst arity stack)) (ZEDzed->scheme (ZEDtails arity stack))))) (#t (ZEDschemefy! (ZEDpop expression) arity-hash (ZEDpush (ZEDpush function (ZEDzed->scheme (ZEDfirst arity stack))) (ZEDzed->scheme (ZEDtails arity stack))))) (else ZEDerr))) (define (ZEDschemefy expression arity-hash) (cond (#t (list (ZEDschemefy! (reverse expression) arity-hash (ZEDstack)))) (else ZEDerr))) (define (ZEDsentence-less? sentence1 sentence2) (cond ((null? sentence2) #f) ((null? sentence1) #t) ((ZEDcharacter-less? (car sentence1) (car sentence2)) #t) ((ZEDcharacter-less? (car sentence2) (car sentence1)) #f) (#t (ZEDsentence-less? (cdr sentence1) (cdr sentence2))) (else ZEDerr))) (define (ZEDsentences! program collect1 collect2) (cond ((null? program) collect2) ((eqv? #\newline (car program)) (ZEDsentences! (cdr program) ZEDnil (cons (reverse collect1) collect2))) (#t (ZEDsentences! (cdr program) (cons (car program) collect1) collect2)) (else ZEDerr))) (define (ZEDsentences program) (cond (#t (reverse (ZEDsentences! (append program (list #\newline)) ZEDnil ZEDnil))) (else ZEDerr))) (define (ZEDslashefy character) (cond ((eqv? #\" character) (list #\\ #\")) ((eqv? #\\ character) (list #\\ #\\)) (#t (list character)) (else ZEDerr))) (define (ZEDsort!a jumble) (cond (#t (map list jumble)) (else ZEDerr))) (define (ZEDsort!b comparator jumble) (cond ((null? jumble) ZEDnil) ((null? (cdr jumble)) jumble) (#t (ZEDsort!b comparator (cons (ZEDmerge comparator (car jumble) (cadr jumble)) (ZEDsort!b comparator (cddr jumble))))) (else ZEDerr))) (define (ZEDsort comparator jumble) (cond (#t (car (ZEDsort!b comparator (ZEDsort!a jumble)))) (else ZEDerr))) (define (ZEDspace-newline! program collect) (cond ((or (null? program) (null? (cdr program))) (ZEDgr "return" (append program collect))) ((and (eqv? #\space (car program)) (eqv? #\newline (cadr program))) (ZEDgr "dispose" (ZEDspace-newline! (cdr program) collect))) (#t (ZEDgr "save" (ZEDspace-newline! (cdr program) (cons (car program) collect)))) (else ZEDerr))) (define (ZEDspace-newline program) (cond (#t (reverse (ZEDspace-newline! program ZEDnil))) (else ZEDerr))) (define (ZEDstack) (cond (#t ZEDnil) (else ZEDerr))) (define (ZEDsymbol-character character) (cond ((char=? character #\@) (list #\@ #\@)) ((char=? character #\[) (list #\@ #\1)) ((char=? character #\]) (list #\@ #\2)) ((char=? character #\{) (list #\@ #\3)) ((char=? character #\}) (list #\@ #\4)) ((char=? character #\') (list #\@ #\q)) ((char=? character #\`) (list #\@ #\Q)) ((char=? character #\,) (list #\@ #\c)) ((char=? character #\:) (list #\@ #\C)) ((char=? character #\;) (list #\@ #\s)) ((char=? character #\\) (list #\@ #\b)) (#t (list character)) (else ZEDerr))) (define (ZEDsymbolize part) (cond ((symbol? part) (ZEDzedefy (symbol->string part))) (#t (string->symbol part)) (else ZEDerr))) (define (ZEDtab-replace! program collect) (cond ((null? program) collect) ((eqv? #\tab (car program)) (ZEDtab-replace! (cdr program) (cons #\space collect))) (#t (ZEDtab-replace! (cdr program) (cons (car program) collect))) (else ZEDerr))) (define (ZEDtab-replace program) (cond (#t (reverse (ZEDtab-replace! program ZEDnil))) (else ZEDerr))) (define (ZEDtails number list) (cond ((null? list) ZEDnil) ((zero? number) list) ((> number 0) (ZEDtails (- number 1) (cdr list))) (else ZEDerr))) (define (ZEDtop stack) (cond (#t (car stack)) (else ZEDerr))) (define (ZEDverb gather-verb) (cond ((and (not (null? (cdr gather-verb))) (eqv? #\" (car gather-verb)) (eqv? #\" (car (reverse gather-verb)))) (list->string (cdr (reverse (cdr (reverse gather-verb)))))) (#t (string->symbol (list->string gather-verb))) (else ZEDerr))) (define (ZEDwrite-all program) (cond ((null? program) ZEDerr) (#t (ZEDwrite-all (begin (write-char (car program)) (cdr program)))) (else ZEDerr))) (define (ZEDzed->scheme! value collect) (cond ((null? value) (reverse collect)) (#t (ZEDzed->scheme! (ZED! value) (cons (ZEDzed->scheme (ZED1 value)) collect))) (else ZEDerr))) (define (ZEDzed->scheme value) (cond ((not (pair? value)) value) (#t (ZEDzed->scheme! value ZEDnil)) (else ZEDerr))) (define (ZEDzedefy string) (cond (#t (string->symbol (list->string (append (list #\Z #\E #\D) (ZEDflatten (map ZEDsymbol-character (string->list string))))))) (else ZEDerr))))
